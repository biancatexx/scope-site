"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TaskOrchestrator = void 0;
const tslib_1 = require("tslib");
const workspace_1 = require("@nrwl/tao/src/shared/workspace");
const fs_1 = require("fs");
const output_1 = require("../utilities/output");
const cache_1 = require("./cache");
const tasks_runner_1 = require("./tasks-runner");
const utils_1 = require("./utils");
const perf_hooks_1 = require("perf_hooks");
const forked_process_task_runner_1 = require("./forked-process-task-runner");
const app_root_1 = require("../utilities/app-root");
class TaskOrchestrator {
    constructor(hasher, initiatingProject, projectGraph, taskGraph, options, hideCachedOutput) {
        this.hasher = hasher;
        this.initiatingProject = initiatingProject;
        this.projectGraph = projectGraph;
        this.taskGraph = taskGraph;
        this.options = options;
        this.hideCachedOutput = hideCachedOutput;
        this.cache = new cache_1.Cache(this.options);
        this.timings = {};
        this.completedTasks = {};
        this.inProgressTasks = {};
        this.scheduledTasks = [];
        this.waitingForTasks = [];
        this.reverseTaskDeps = {};
        this.workspace = new workspace_1.Workspaces(app_root_1.appRootPath);
        this.forkedProcessTaskRunner = new forked_process_task_runner_1.ForkedProcessTaskRunner(this.options);
    }
    run() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.calculateReverseDeps();
            for (let root of this.taskGraph.roots) {
                yield this.scheduleTask(root);
            }
            perf_hooks_1.performance.mark('task-execution-begins');
            const res = yield this.runTasks();
            perf_hooks_1.performance.mark('task-execution-ends');
            perf_hooks_1.performance.measure('command-execution', 'task-execution-begins', 'task-execution-ends');
            this.cache.removeOldCacheRecords();
            return res;
        });
    }
    calculateReverseDeps() {
        Object.keys(this.taskGraph.tasks).forEach((t) => {
            this.reverseTaskDeps[t] = [];
        });
        Object.keys(this.taskGraph.dependencies).forEach((taskId) => {
            this.taskGraph.dependencies[taskId].forEach((d) => {
                this.reverseTaskDeps[d].push(taskId);
            });
        });
    }
    nextTask() {
        if (this.scheduledTasks.length > 0) {
            return this.taskGraph.tasks[this.scheduledTasks.pop()];
        }
        else {
            return null;
        }
    }
    complete(taskId, status) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.completedTasks[taskId] === undefined) {
                this.completedTasks[taskId] = status;
                const everyTaskDependingOnTaskId = this.reverseTaskDeps[taskId];
                for (let t of everyTaskDependingOnTaskId) {
                    if (this.allDepsAreSuccessful(t)) {
                        yield this.scheduleTask(t);
                    }
                    else if (this.allDepsAreCompleted(t)) {
                        yield this.complete(t, 'skipped');
                    }
                }
            }
            // release blocked threads
            this.waitingForTasks.forEach((f) => f(null));
            this.waitingForTasks.length = 0;
        });
    }
    scheduleTask(taskId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.inProgressTasks[taskId]) {
                this.inProgressTasks[taskId] = true;
                const task = this.taskGraph.tasks[taskId];
                const { value, details } = yield this.hashTask(task);
                task.hash = value;
                task.hashDetails = details;
                this.scheduledTasks.push(taskId);
                // TODO vsavkin: remove the if statement after Nx 14 is out
                if (this.options.lifeCycle.scheduleTask) {
                    this.options.lifeCycle.scheduleTask(task);
                }
            }
        });
    }
    allDepsAreSuccessful(taskId) {
        for (let t of this.taskGraph.dependencies[taskId]) {
            if (this.completedTasks[t] !== 'success' &&
                this.completedTasks[t] !== 'cache')
                return false;
        }
        return true;
    }
    allDepsAreCompleted(taskId) {
        for (let t of this.taskGraph.dependencies[taskId]) {
            if (this.completedTasks[t] === undefined)
                return false;
        }
        return true;
    }
    hashTask(task) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const hasher = this.customHasher(task);
            if (hasher) {
                return hasher(task, this.taskGraph, this.hasher);
            }
            else {
                return this.hasher.hashTaskWithDepsAndContext(task);
            }
        });
    }
    runTasks() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const that = this;
            function takeFromQueue() {
                return tslib_1.__awaiter(this, void 0, void 0, function* () {
                    // completed all the tasks
                    if (Object.keys(that.completedTasks).length ===
                        Object.keys(that.taskGraph.tasks).length) {
                        return null;
                    }
                    const task = that.nextTask();
                    if (!task) {
                        // block until some other task completes, then try again
                        return new Promise((res) => that.waitingForTasks.push(res)).then(takeFromQueue);
                    }
                    const doNotSkipCache = that.options.skipNxCache === false ||
                        that.options.skipNxCache === undefined;
                    if (doNotSkipCache && that.isCacheableTask(task)) {
                        const cachedResult = yield that.cache.get(task);
                        if (cachedResult && cachedResult.code === 0) {
                            yield that.applyCachedResult({ task, cachedResult });
                            return takeFromQueue();
                        }
                    }
                    yield that.runTaskInForkedProcess(task);
                    return takeFromQueue();
                });
            }
            const wait = [];
            // // initial seeding
            const maxParallel = this.options.parallel
                ? this.options.maxParallel || 3
                : 1;
            for (let i = 0; i < maxParallel; ++i) {
                wait.push(takeFromQueue());
            }
            yield Promise.all(wait);
            return Object.keys(this.completedTasks).map((taskId) => {
                if (this.completedTasks[taskId] === 'cache') {
                    return {
                        task: this.taskGraph.tasks[taskId],
                        type: tasks_runner_1.AffectedEventType.TaskCacheRead,
                        success: true,
                    };
                }
                else if (this.completedTasks[taskId] === 'success') {
                    return {
                        task: this.taskGraph.tasks[taskId],
                        type: tasks_runner_1.AffectedEventType.TaskComplete,
                        success: true,
                    };
                }
                else if (this.completedTasks[taskId] === 'failure') {
                    return {
                        task: this.taskGraph.tasks[taskId],
                        type: tasks_runner_1.AffectedEventType.TaskComplete,
                        success: false,
                    };
                }
                else if (this.completedTasks[taskId] === 'skipped') {
                    return {
                        task: this.taskGraph.tasks[taskId],
                        type: tasks_runner_1.AffectedEventType.TaskDependencyFailed,
                        success: false,
                    };
                }
            });
        });
    }
    runTaskInForkedProcess(task) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                this.storeStartTime(task);
                this.options.lifeCycle.startTask(task);
                const taskOutputs = utils_1.getOutputs(this.projectGraph.nodes, task);
                const outputPath = this.cache.temporaryOutputPath(task);
                const forwardOutput = this.shouldForwardOutput(task);
                this.cache.removeRecordedOutputsHashes(taskOutputs);
                const pipeOutput = this.pipeOutputCapture(task);
                const { code, terminalOutput } = pipeOutput
                    ? yield this.forkedProcessTaskRunner.forkProcessPipeOutputCapture(task, {
                        forwardOutput,
                    })
                    : yield this.forkedProcessTaskRunner.forkProcessDirectOutputCapture(task, {
                        temporaryOutputPath: outputPath,
                        forwardOutput,
                    });
                this.storeEndTime(task);
                if (this.shouldCacheTaskResult(task, code)) {
                    yield this.cache.put(task, terminalOutput, taskOutputs, code);
                    this.cache.recordOutputsHash(taskOutputs, task.hash);
                    if (pipeOutput) {
                        fs_1.writeFileSync(outputPath, terminalOutput);
                    }
                }
                this.options.lifeCycle.endTask(task, code);
                yield this.complete(task.id, code === 0 ? 'success' : 'failure');
            }
            catch (e) {
                yield this.complete(task.id, 'failure');
            }
        });
    }
    applyCachedResult(t) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.storeStartTime(t.task);
            this.options.lifeCycle.startTask(t.task);
            const outputs = utils_1.getOutputs(this.projectGraph.nodes, t.task);
            const shouldCopyOutputsFromCache = this.cache.shouldCopyOutputsFromCache(t, outputs);
            if (shouldCopyOutputsFromCache) {
                this.cache.copyFilesFromCache(t.task.hash, t.cachedResult, outputs);
            }
            if ((!this.initiatingProject ||
                this.initiatingProject === t.task.target.project) &&
                !this.hideCachedOutput) {
                const args = utils_1.getCommandArgsForTask(t.task);
                output_1.output.logCommand(`nx ${args.join(' ')}`, shouldCopyOutputsFromCache
                    ? output_1.TaskCacheStatus.RetrievedFromCache
                    : output_1.TaskCacheStatus.MatchedExistingOutput);
                process.stdout.write(t.cachedResult.terminalOutput);
            }
            this.options.lifeCycle.endTask(t.task, t.cachedResult.code);
            this.storeEndTime(t.task);
            yield this.complete(t.task.id, 'cache');
        });
    }
    storeStartTime(t) {
        this.timings[`${t.target.project}:${t.target.target}`] = {
            start: new Date().getTime(),
            end: undefined,
        };
    }
    storeEndTime(t) {
        this.timings[`${t.target.project}:${t.target.target}`].end =
            new Date().getTime();
    }
    customHasher(task) {
        try {
            const f = utils_1.getExecutorForTask(task, this.workspace).hasherFactory;
            return f ? f() : null;
        }
        catch (e) {
            console.error(e);
            throw new Error(`Unable to load hasher for task "${task.id}"`);
        }
    }
    pipeOutputCapture(task) {
        try {
            return (utils_1.getExecutorForTask(task, this.workspace).schema.outputCapture === 'pipe');
        }
        catch (e) {
            return false;
        }
    }
    shouldCacheTaskResult(task, code) {
        // TODO: vsavkin make caching failures the default in Nx 12.1
        return (this.isCacheableTask(task) &&
            (process.env.NX_CACHE_FAILURES == 'true' ? true : code === 0));
    }
    shouldForwardOutput(task) {
        if (!this.isCacheableTask(task))
            return true;
        if (!this.options.parallel)
            return true;
        if (task.target.project === this.initiatingProject)
            return true;
        return false;
    }
    isCacheableTask(task) {
        const cacheable = this.options.cacheableOperations || this.options.cacheableTargets;
        return (cacheable &&
            cacheable.indexOf(task.target.target) > -1 &&
            !this.longRunningTask(task));
    }
    longRunningTask(task) {
        return !!task.overrides['watch'];
    }
}
exports.TaskOrchestrator = TaskOrchestrator;
//# sourceMappingURL=task-orchestrator.js.map