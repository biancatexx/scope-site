import type { ProjectGraph } from '@nrwl/devkit';
import { Cache } from './cache';
import { DefaultTasksRunnerOptions } from './default-tasks-runner';
import { AffectedEventType, Task } from './tasks-runner';
import { TaskGraph } from './task-graph-creator';
import { Hasher } from '../core/hasher/hasher';
export declare class TaskOrchestrator {
    private readonly hasher;
    private readonly initiatingProject;
    private readonly projectGraph;
    private readonly taskGraph;
    private readonly options;
    private readonly hideCachedOutput;
    cache: Cache;
    timings: {
        [target: string]: {
            start: number;
            end: number;
        };
    };
    completedTasks: {
        [id: string]: 'success' | 'failure' | 'skipped' | 'cache';
    };
    inProgressTasks: {
        [id: string]: boolean;
    };
    scheduledTasks: string[];
    waitingForTasks: Function[];
    reverseTaskDeps: Record<string, string[]>;
    private workspace;
    private forkedProcessTaskRunner;
    constructor(hasher: Hasher, initiatingProject: string | undefined, projectGraph: ProjectGraph, taskGraph: TaskGraph, options: DefaultTasksRunnerOptions, hideCachedOutput: boolean);
    run(): Promise<{
        task: Task;
        type: AffectedEventType;
        success: boolean;
    }[]>;
    private calculateReverseDeps;
    private nextTask;
    private complete;
    private scheduleTask;
    private allDepsAreSuccessful;
    private allDepsAreCompleted;
    private hashTask;
    private runTasks;
    private runTaskInForkedProcess;
    private applyCachedResult;
    private storeStartTime;
    private storeEndTime;
    private customHasher;
    private pipeOutputCapture;
    private shouldCacheTaskResult;
    private shouldForwardOutput;
    private isCacheableTask;
    private longRunningTask;
}
