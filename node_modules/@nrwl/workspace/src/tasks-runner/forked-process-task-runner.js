"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ForkedProcessTaskRunner = void 0;
const fs_1 = require("fs");
const dotenv = require("dotenv");
const child_process_1 = require("child_process");
const app_root_1 = require("../utilities/app-root");
const output_1 = require("../utilities/output");
const utils_1 = require("./utils");
class ForkedProcessTaskRunner {
    constructor(options) {
        this.options = options;
        this.workspaceRoot = app_root_1.appRootPath;
        this.cliPath = utils_1.getCliPath(this.workspaceRoot);
        this.processes = [];
        this.setupOnProcessExitListener();
    }
    forkProcessPipeOutputCapture(task, { forwardOutput }) {
        return new Promise((res, rej) => {
            try {
                const env = this.envForForkedProcess(task, undefined, forwardOutput, process.env.FORCE_COLOR === undefined
                    ? 'true'
                    : process.env.FORCE_COLOR);
                const args = utils_1.getCommandArgsForTask(task);
                const commandLine = `nx ${args.join(' ')}`;
                if (forwardOutput) {
                    output_1.output.logCommand(commandLine);
                }
                const p = child_process_1.fork(this.cliPath, args, {
                    stdio: ['inherit', 'pipe', 'pipe', 'ipc'],
                    env,
                });
                this.processes.push(p);
                let out = [];
                let outWithErr = [];
                p.stdout.on('data', (chunk) => {
                    if (forwardOutput) {
                        process.stdout.write(chunk);
                    }
                    out.push(chunk.toString());
                    outWithErr.push(chunk.toString());
                });
                p.stderr.on('data', (chunk) => {
                    if (forwardOutput) {
                        process.stderr.write(chunk);
                    }
                    outWithErr.push(chunk.toString());
                });
                p.on('exit', (code, signal) => {
                    if (code === null)
                        code = this.signalToCode(signal);
                    // we didn't print any output as we were running the command
                    // print all the collected output|
                    const terminalOutput = outWithErr.join('');
                    if (!forwardOutput) {
                        output_1.output.logCommand(commandLine);
                        process.stdout.write(terminalOutput);
                    }
                    res({ code, terminalOutput });
                });
            }
            catch (e) {
                console.error(e);
                rej(e);
            }
        });
    }
    forkProcessDirectOutputCapture(task, { forwardOutput, temporaryOutputPath, }) {
        return new Promise((res, rej) => {
            try {
                const env = this.envForForkedProcess(task, temporaryOutputPath, forwardOutput, undefined);
                const args = utils_1.getCommandArgsForTask(task);
                const commandLine = `nx ${args.join(' ')}`;
                if (forwardOutput) {
                    output_1.output.logCommand(commandLine);
                }
                const p = child_process_1.fork(this.cliPath, args, {
                    stdio: ['inherit', 'inherit', 'inherit', 'ipc'],
                    env,
                });
                this.processes.push(p);
                p.on('exit', (code, signal) => {
                    if (code === null)
                        code = this.signalToCode(signal);
                    // we didn't print any output as we were running the command
                    // print all the collected output
                    const terminalOutput = this.readTerminalOutput(temporaryOutputPath);
                    if (!forwardOutput) {
                        output_1.output.logCommand(commandLine);
                        if (terminalOutput) {
                            process.stdout.write(terminalOutput);
                        }
                        else {
                            console.error(`Nx could not find process's output. Run the command without --parallel.`);
                        }
                    }
                    res({
                        code,
                        terminalOutput,
                    });
                });
            }
            catch (e) {
                console.error(e);
                rej(e);
            }
        });
    }
    readTerminalOutput(outputPath) {
        try {
            return fs_1.readFileSync(outputPath).toString();
        }
        catch (e) {
            return null;
        }
    }
    envForForkedProcess(task, outputPath, forwardOutput, forceColor) {
        const envsFromFiles = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, parseEnv('.env')), parseEnv('.local.env')), parseEnv('.env.local')), parseEnv(`${task.projectRoot}/.env`)), parseEnv(`${task.projectRoot}/.local.env`)), parseEnv(`${task.projectRoot}/.env.local`));
        const env = Object.assign(Object.assign(Object.assign(Object.assign({}, envsFromFiles), { FORCE_COLOR: forceColor }), process.env), { NX_TASK_HASH: task.hash, NX_INVOKED_BY_RUNNER: 'true', NX_WORKSPACE_ROOT: this.workspaceRoot });
        if (outputPath) {
            env.NX_TERMINAL_OUTPUT_PATH = outputPath;
            if (this.options.captureStderr) {
                env.NX_TERMINAL_CAPTURE_STDERR = 'true';
            }
            // TODO: remove this once we have a reasonable way to configure it
            if (task.target.target === 'test') {
                env.NX_TERMINAL_CAPTURE_STDERR = 'true';
            }
            if (forwardOutput) {
                env.NX_FORWARD_OUTPUT = 'true';
            }
        }
        return env;
    }
    signalToCode(signal) {
        if (signal === 'SIGHUP')
            return 128 + 1;
        if (signal === 'SIGINT')
            return 128 + 2;
        if (signal === 'SIGTERM')
            return 128 + 15;
        return 128;
    }
    setupOnProcessExitListener() {
        process.on('SIGINT', () => {
            this.processes.forEach((p) => {
                p.kill('SIGTERM');
            });
            // we exit here because we don't need to write anything to cache.
            process.exit();
        });
        process.on('SIGTERM', () => {
            this.processes.forEach((p) => {
                p.kill('SIGTERM');
            });
            // no exit here because we expect child processes to terminate which
            // will store results to the cache and will terminate this process
        });
        process.on('SIGHUP', () => {
            this.processes.forEach((p) => {
                p.kill('SIGTERM');
            });
            // no exit here because we expect child processes to terminate which
            // will store results to the cache and will terminate this process
        });
    }
}
exports.ForkedProcessTaskRunner = ForkedProcessTaskRunner;
function parseEnv(path) {
    try {
        const envContents = fs_1.readFileSync(path);
        return dotenv.parse(envContents);
    }
    catch (e) { }
}
//# sourceMappingURL=forked-process-task-runner.js.map